INCLUDE "Hardware.inc"
INCLUDE "rgbgrafx/rgbgrafx.inc"

Section "Twister Data",DATA
INCLUDE "imagedata/twister.inc"

Section "Twister scene",CODE
scene_twister::
  di
  call initialize_interrupts
  ei
  ; Set all palette colors to black for the duration of loading image data
  RGBG_WaitForVRAM
  ld A, $FF
  ld [rBGP], A

  ; Initialize high byte of the tileset starting address
  ld A, $80
  ld [RGBG_tileset], A
  ; Load tile patterns to VRAM
  ld BC, twister_image_tile_data
  ld D, $FF
  ld E, 0
  RGBG_WaitForVRAM
  call RGBG_LoadTiles

  ; Initialize high byte of the tilemap starting address
  ld A, $98
  ld [RGBG_tilemap], A

  ; Set tilemap offset to zero
  xor A
  ld [RGBG_map_offset], A

  ; Load tile map
  RGBG_WaitForVRAM
  ld BC, twister_image_map_data
  ld H, $0
  ld L, $0
  ld E, twister_image_tile_map_width
  ld D, twister_image_tile_map_height
  call RGBG_SetTileMap

  ; Reset background scroll registers
  xor A
  ld [rSCX], A
  ld [rSCY], A

  ; When timer interrupt triggers, load 0 to TIMA
  ld [rTMA], A
  ; Initialize timer variable to zero
  ld [timer], A

  ; Set timer to increment 4096 times a second
  ld A, 4
  ld [rTAC], A

  ; Set timer interrupt
  ld BC, twister_timer
  call set_timer_interrupt

  ; Set proper values for LCDC register
  ld A, (LCDCF_ON | LCDCF_WINOFF | LCDCF_BG8000 | LCDCF_BG9800 | LCDCF_BGON)
  ld [rLCDC], A

  ; Set LCDC interrupt to trigger when LYC == LY
  ld A, (STATF_LYC)
  ld [rSTAT], A

  ; Enable VBlank, LCDC and Timer interrupts
  di
  ld A, [rIE]
  and %11110000
  ld B, (IEF_LCDC | IEF_VBLANK | IEF_TIMER)
  or B
  ld [rIE], A

  ld BC, twister_vblank
  call set_vblank_interrupt

  ld BC, twister_lcdc
  call set_lcdc_interrupt
  ei

  ; Initialize LYC to $00
  ld A, $00
  ld [rLYC], A
  ; Set twister_offset to zero at start
  ld [twister_offset], A

  ; Reset color palette to default
  RGBG_WaitForVRAM
  ld A, %11100100
  ld [rBGP], A
  ld [rOBP0], A
  ld [rOBP1], A

.loop:
  halt
  ld A, [timer]
  ; Exit after 80 / 16 = 5 seconds
  cp 80
  jr nz, .loop
  ret

twister_timer:
  ld A, [timer]
  inc A
  ld [timer], A
  ret

twister_vblank:
  ; Increment twister_offset
  ld A, [twister_offset]
  inc A
  ld [twister_offset], A
  ret

twister_lcdc:
  ; Load raster line number to A
  ld A, [rLY]
  ; Store raster line in B
  ld B, A
  ; Load per-frame offset to A
  ld A, [twister_offset]
  ; Add offset to raster line number
  add B
  ; Get sine(rasterline + offset) and store in A
  call get_sine
  ; Keep sine in range 0-63
  cp 63
  jr c, .in_range
  sub 64
.in_range:
  ; Jump 64 lines down every 8 lines to create checkerboard
  sub B
  bit 3, B
  jr z, .no_flip
  add 64
.no_flip:
  ; Store result in Y scroll register
  ld [rSCY], A
  ; Increment LYC to trigger interrupt again at next scanline
  ld A, [rLYC]
  inc A
  cp 144
  jr c, .in_frame
  ; If at row 144, set LYC to 0
  xor A
.in_frame:
  ld [rLYC], A
  ret

get_sine:
  ld H, $30
  ld L, A
  ld A, [HL]
  ret

Section "Sine LUT",HOME[$3000] ; Alignment to 00 important
; This LUT contains one 256-byte sine period varying between 0 and 32
sine_lut:
ANGLE=0.0
      REPT 256
      DB (MUL(62.0, SIN(ANGLE))+62.0)>>16
ANGLE=ANGLE+256.0
      ENDR

Section "Twister variables",BSS
twister_offset: DS 1
timer: DS 1
