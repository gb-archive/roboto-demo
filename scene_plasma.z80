INCLUDE "Hardware.inc"
INCLUDE "rgbgrafx/rgbgrafx.inc"

; NOTE: HRAM $FF90-> is free
TIME EQU $90

Section "Plasma scene",CODE
scene_plasma::
  ; Set all palette colors to black for the duration of scene setup
  RGBG_WaitForVRAM
  ld A, $FF
  ld [rBGP], A

  ; Reset background scroll registers
  xor A
  ld [rSCX], A
  ld [rSCY], A

  ; Set time offset to 0
  ldh [TIME], A

  ; Set LCDC register initial values
  ld A, (LCDCF_ON | LCDCF_WINOFF | LCDCF_BG8000 | LCDCF_BG9800 | LCDCF_BGON)
  ld [rLCDC], A

  di
  ; Clear interrupt handlers
  call initialize_interrupts

  ; Load tiles into VRAM
  call load_tiles

  ; Reset color palette to default
  RGBG_WaitForVRAM
  ld A, %11100100
  ld [rBGP], A
  ld [rOBP0], A
  ld [rOBP1], A
  ei

.loop:
  halt
  ; Update plasma buffer contents
  call update_plasma_buffer

  ; Write buffer contents to VRAM
  ; using double buffering.
  ld L, $00
  ld A, [rLCDC]
  bit 3, A
  jr nz, .write_to_bg9800
.write_to_bg9c00:
  ld H, $9C
  jr .write
.write_to_bg9800:
  ld H, $98
.write
  call write_plasma_to_vram
  ld B, LCDCF_BG9C00
  ld A, [rLCDC]
  xor B
  ld [rLCDC], A

  ; Increment time offset
  ldh A, [TIME]
  inc A
  ldh [TIME], A

  jr .loop
  ret

update_plasma_buffer:
  ld HL, plasma_buffer
  ld D, 18 ; Row counter
.row_loop:
  ld B, 20 ; Column counter
.tile_loop:
  ; The magic happens here!
  push HL ; Store address to current place in plasma buffer
  ; Point HL to sine lut
  ld H, $31

  ldh A, [TIME]
  ld L, A
  ld A, [HL]
  srl A
  srl A
  ; Now A has sin(time)/4
  add B
  ld L, A
  ld A, [HL]
  ld E, A
  ; Now E has sin(col + sin(time)/4)

  ldh A, [TIME]
  sub 100
  ld L, A
  ld A, [HL]
  srl A
  ; Now A has sin(time-100)/2
  add D
  ld L, A
  ld A, [HL]
  add E
  ld E, A
  ; Now E has sin(col + sin(time)/4) + sin(sin(time-100)/2+row)

  ldh A, [TIME]
  add A
  add E
  ld L, A
  ld A, [HL]
  ; Now A has sin(2*time + sin(col + sin(time)/4) + sin(sin(time-100)/2+row))

  and 63 ; Keep result in range 0-63
  ; Store result A in plasma buffer and increment HL
  pop HL
  ldi [HL], A

  dec B
  jr nz, .tile_loop
  dec D
  jr nz, .row_loop
  ret

write_plasma_to_vram:
  ; Code writes 18 lines (tiles 0-19) to [HL] from plasma_data
  ld DE, plasma_buffer
  ld B, 18 ; Row counter
.row_loop:
  push BC
  ld B, 10 ; Run 10 times, since inner loop does two iterations (=20 tiles)
.tile_loop:
  RGBG_WaitForVRAM ; Wait for VRAM to become available
  ld A, [DE]
  ldi [HL], A
  inc DE

  ld A, [DE]
  ldi [HL], A
  inc DE

  dec B ; Decrement column counter
  jr nz, .tile_loop
  ld BC, $000C ; Skip $C non-visible tiles on row
  add HL, BC
  pop BC
  dec B ; Decrement row counter
  jr nz, .row_loop
  ret

load_tiles:
  RGBG_WaitForVRAM
  ld A, $80
  ld [RGBG_tileset], A
  ld BC, plasma_tiles ; Plasma tile data address
  ld D, 64 ; Number of tiles
  ld E, 0 ; Offset required by RGBG
  call RGBG_LoadTiles
  ret

INCLUDE "imagedata/plasma_tiles.inc"

Section "Plasma sine LUT",HOME[$3100]
plasma_sine_lut:
ANGLE=0.0
      REPT 256
      DB (MUL(32.0, SIN(ANGLE))+32.0)>>16
ANGLE=ANGLE+1024.0
      ENDR

Section "Plasma variables",BSS
plasma_buffer: DS 360
